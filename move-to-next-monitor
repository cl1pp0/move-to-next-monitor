#!/bin/bash
#
# Move the current window to the next monitor.
#
# Also works only on one X screen (which is the most common case).
#
# Props to
# http://icyrock.com/blog/2012/05/xubuntu-moving-windows-between-monitors/
#
# Unfortunately, both "xdotool getwindowgeometry --shell $window_id" and
# checking "-geometry" of "xwininfo -id $window_id" are not sufficient, as
# the first command does not respect panel/decoration offsets and the second
# will sometimes give a "-0-0" geometry. This is why we resort to "xwininfo".

read -r screen_width screen_height <<< $(xdpyinfo | sed -n -E 's/^.*dimensions: +([0-9]+)x([0-9]+) +pixels.*$/\1 \2/p')

# xdotool always seems to return dimension of first display, not of which the active window is on.
# see https://github.com/jordansissel/xdotool/issues/31
#display_width=$(xdotool getdisplaygeometry | cut -d" " -f1)
#display_height=$(xdotool getdisplaygeometry | cut -d" " -f2)

# Workaround: Use xrandr for getting the monitor resolution -> other suggestions welcome
read -r display_width[0] display_height[0] <<< $(xrandr | sed -n -E 's/^.* connected ([0-9]+)x([0-9]+)\+0\+0.*$/\1 \2/p')
read -r display_width[1] display_height[1] <<< $(xrandr | sed -n -E 's/^.* connected ([0-9]+)x([0-9]+)\+'"${display_width[0]}"'\+0.*$/\1 \2/p')
display_index=0

window_id=$(xdotool getactivewindow)

# Read window position
read -r x y <<< $(xwininfo -id "$window_id" | awk '/Absolute upper-left X:/ { x = $4 }; /Absolute upper-left Y:/ { y = $4 }; END { print x, y }')

# Evaluate on which display the window is
if [ "$x" -ge "${display_width[0]}" ]; then
    display_index=1
fi

# Remember if it was maximized.
read -r horz_maxed vert_maxed <<< $(xprop -id "$window_id" _NET_WM_STATE | awk '{if (/MAXIMIZED_HORZ/) horz = 1; if (/MAXIMIZED_VERT/) vert = 1}; END {print horz, vert}')

# Un-maximize current window so that we can move it
wmctrl -ir "$window_id" -b remove,maximized_vert,maximized_horz

# Subtract any offsets caused by panels or window decorations
read -r x_offset y_offset <<< $(xwininfo -id "$window_id" | awk '/Relative upper-left X:/ { x = $4 }; /Relative upper-left Y:/ { y = $4 }; END { print x, y }')
x=$((x - x_offset))
y=$((y - y_offset))

# Compute new X and Y position
new_x=$((x + ${display_width[display_index]}))
new_y=$((y + display_height))

# If we would move off the right-most monitor, we set it to the left one.
# We also respect the window's width here: moving a window partly off a monitor won't happen
read -r width height <<< $(xdotool getwindowgeometry "$window_id" | sed -n -E 's/^.*Geometry: +([0-9]+)x([0-9]+).*$/\1 \2/p')
if [ "$(((new_x + width / 2)*display_index))" -gt "$screen_width" ]; then
    new_x=$((new_x - screen_width))
elif [ "$((new_x + width))" -gt "$screen_width" ]; then
    new_x=$((new_x - (new_x + width - screen_width)))
fi

if [ "$((new_y + height / 2))" -gt "$screen_height" ]; then
    new_y=$((new_y - screen_height))
fi

# Don't move off the left side.
if [ "$new_x" -lt 0 ]; then
    new_x=0
fi

# Don't move off the bottom
if [ "$new_y" -lt 0 ]; then
    new_y=0
fi

# Move the window
xdotool windowmove "$window_id" "$new_x" "$new_y"

# Maximize window again, if it was before
if [ -n "${horz_maxed}" ] && [ -n "${vert_maxed}" ]; then
    wmctrl -ir "$window_id" -b add,maximized_vert,maximized_horz
elif [ -n  "${horz_maxed}" ]; then
    wmctrl -ir "$window_id" -b add,maximized_horz
elif [ -n  "${vert_maxed}" ]; then
    wmctrl -ir "$window_id" -b add,maximized_vert
fi
